---
title: 'WithTime: 데이트 코스 추천 서비스의 프론트엔드 아키텍처 및 자동화 전략'
date: '2025-08-25'
desc: 'Zustand를 활용한 상태 관리 분리 전략과 CodeRabbit 도입을 통한 코드 리뷰 효율화 과정'
tags: ['React', 'Zustand', 'CI/CD', 'Architecture']
slug: 'withtime-dev-story'
---

## 1. 프로젝트 개요

WithTime은 사용자의 예산과 취향을 분석하여 AI가 최적의 데이트 코스를 추천해 주는 웹 서비스입니다. 프론트엔드 리더로서 팀원 4명과 함께 프로젝트 초기 세팅부터 배포까지 전 과정을 주도했습니다.

이 프로젝트에서 가장 중요하게 생각했던 것은 **"복잡한 상태 관리의 단순화"** 와 **"협업 효율성 증대"** 였습니다.

## 2. 상태 관리 전략: 책임의 분리 (Separation of Concerns)

데이트 코스를 생성하기 위해서는 예산, 지역, 활동 타입 등 수많은 필터 조건이 필요했습니다. 초기에는 하나의 Store에서 모든 상태를 관리하려 했으나, 다음과 같은 문제가 예상되었습니다.

-   문제점: 필터 입력값(Input)과 결과값(Output)이 섞여 있어, 코스 재생성 시 상태 초기화 로직이 복잡해짐.

-   해결책: 상태의 성격에 따라 Store를 물리적으로 분리했습니다.

### Zustand Store 구조화

저는 Zustand를 도입하여 보일러플레이트를 최소화하고, 다음과 같이 Store를 분리했습니다.

1. Filter Store: 사용자가 입력한 조건(Input)만 담당. 새로고침 시에도 유지되도록 Persist 미들웨어 적용.

2. Result Store: 생성된 데이트 코스 결과(Output)만 담당.

```ts
// useFilterStore.ts (조건 관리)
export const useFilterStore = create(
    persist(
        (set) => ({
            budget: 0,
            location: '',
            preferences: [],
            setBudget: (amount) => set({ budget: amount }),
            // ...
        }),
        { name: 'filter-storage' }
    )
);
```

```ts
// useResultStore.ts (결과 관리)
export const useResultStore = create((set) => ({
    courses: [],
    setCourses: (data) => set({ courses: data }),
    clearCourses: () => set({ courses: [] }), // 필터 변경 시 결과만 초기화 용이
}));
```

이러한 분리를 통해 "동일한 필터값으로 코스 재생성" 기능을 구현할 때, FilterStore는 유지하고 ResultStore만 갱신하면 되는 유연한 구조를 갖추게 되었습니다.

## 3. 끊김 없는 사용자 경험: 인증 로직 고도화

로그인 유지와 토큰 관리는 사용자 경험(UX)의 핵심입니다. Access Token이 만료될 때마다 로그아웃이 된다면 사용자는 서비스를 이탈할 것입니다.

이를 방지하기 위해 Axios Interceptor를 활용하여 토큰 만료 시 자동으로 재발급받는 로직을 구현했습니다.

```ts
// axiosInstance.ts
instance.interceptors.response.use(
    (response) => response,
    async (error) => {
        const originalRequest = error.config;

        // 401 에러 발생 시 && 재시도하지 않은 요청일 경우
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;

            try {
                // 토큰 재발급 API 호출
                const { accessToken } = await refreshAccessToken();

                // 헤더 갱신 후 원래 요청 재시도
                originalRequest.headers.Authorization = `Bearer ${accessToken}`;
                return instance(originalRequest);
            } catch (refreshError) {
                // 재발급 실패 시 로그아웃 처리
                useAuthStore.getState().logout();
                return Promise.reject(refreshError);
            }
        }
        return Promise.reject(error);
    }
);
```

## 4. 협업 효율화: AI 코드 리뷰와 자동화

4명의 프론트엔드 개발자가 협업하면서 코드 리뷰의 병목 현상과 스타일 불일치 문제가 발생했습니다. 이를 해결하기 위해 적극적으로 자동화 도구를 도입했습니다.

### 🤖 CodeRabbit 도입

단순한 린트(Lint) 규칙으로는 잡기 어려운 구조적 문제나 가독성 이슈를 해결하기 위해 AI 리뷰어인 CodeRabbit을 도입했습니다.

`.coderabbit.yaml` 커스터마이징: 리뷰 톤을 'Assertive'로 설정하고 출력 언어를 한국어로 고정하여 명확한 피드백을 받도록 설정했습니다.

효과: PR 생성 즉시 요약과 개선 제안이 달리므로, 팀원들은 비즈니스 로직 검토에만 집중할 수 있게 되어 리뷰 속도가 2배 이상 빨라졌습니다.

### ⚙️ CI/CD 파이프라인 구축

Husky & Lint-staged: 커밋 전에 자동으로 코드를 포맷팅하여 스타일 논쟁을 원천 차단했습니다.

GitHub Actions: main 브랜치 병합 시 AWS S3 빌드 및 CloudFront 캐시 무효화까지 자동으로 수행되도록 구성하여 배포 실수를 방지했습니다.

## 5. 마치며

WithTime 프로젝트는 단순한 기능 구현을 넘어, 유지보수 가능한 아키텍처와 팀의 생산성을 고민할 수 있었던 값진 경험이었습니다. 특히 상태 관리 라이브러리의 선택과 구조 설계가 프로젝트 후반부의 개발 속도에 얼마나 큰 영향을 미치는지 체감할 수 있었습니다.
